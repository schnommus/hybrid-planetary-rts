TOP:
- file-mapped resource fetcher system *DONE*
- xml type system *DONE*

ENABLES:
-File-mapped resource fetcher system *DONE*
-Dynamic level editor loading of entity types *DONE*
-Using VBOs for everything
	-Draw ordering by append & sort!
	-Stuff on same draw level is rendered top to bottom? Would be appropriate.

if entFactory creates
class AttributeList { map<string, string> atts; String(key); Int(key); float()... }

Components could implement
static SpriteComponent *SpriteComponent::FromAttributes( AttributeList att ) {
	return new SpriteComponent( att.String("file_name"), att.Int("animation_frames"), ... );
}

So EntFactory builds on init()
map< typenames::string, vector<ComponentDescriptor> >

(ComponentDescriptor.type; ComponentDescriptor.attributes)

And then on a request to construct, does physical component creation returning entity pointer.

At the end of components.h->
#define register_component(s, t) if( desc.name == s ) return t::FromAttributes( desc.attributes )
Component *FromDescriptor( ComponentDescriptor & desc ) {
	register_component("sprite-component", SpriteComponent);
	...
}

Set vblank_mode=0 env. variable for fps analysis in linux

-Add LevelEditing ProcessingSystem class; and put all level stuff in there. *DONE*
-Show string of currently placing type *DONE* (Images = better)
-Just pass everything relevent to the leveleditor which will hack it's way into other systems (if necessary) *DONE*
-It should be possible to render terrain nodes within the leveleditor class without interfering with the RenderSystem *DONE* (Compiler flag)
-Gotta delete nodes that are nearby within a threshold. *DONE*
-Also just adding a delete function in the first place would be useful. *DONE*

-File-mapped resource fetcher system; to keep media directories isolated.
-Move type descriptors in the level system into a class to get rid of ugly array indexing -> probably should implement fully-fledged type system if this is gonna happen *DONE*
-Move drawing of selected types into a function because it smells *DONE*
-Fix the ReverseUVTransform function. Probably some float/mathematical anomaly; but only on one pole of the planetoid, it's calculations stuff up in about a 20 pixel radius.
-Move star system into minimap code *DONE*
-Use VBOs for:
	-Star system *DONE*
	-Tile drawing (Will involve concatenating tileset & storing tiles in a grid of pointers to tile properties? Flyweight.)
-For tiles:
	-Change names of images to a number
	-Write program that converts numbered terrain pieces into terrain spritesheet
	-Create a class that represents terrain pieces [part of the type system] (Just use existing TerrainNode component?!)
	-^^ is used for nodes
	-BackGroundterrain keeps a pointer to the nearest node's [typesystem terrain class]
	-Used for sfx (i.e snow; no snow; tracks etc, difficult to move)
	-Backgroundterrain will instead use flyweight pattern; which is 2D array of pointers to parent node [or however typesystem goes]
	-Rest of game can query background system; and pull out a terrain type pointer whenever need arises.

TYPE SYSTEM
-Have a directory full of entity XML files. (Or perhaps JSON) *DONE*
-Auto-scan the directory to populate type database (esp. for level editor!) (filename INSIGNIFICANT. but I.e <type-name: tree> ) *DONE*
-XML illustrates all the components; and component parameters. *DONE*
-xml is used to instantiate the entity; creating it from the description. *DONE*

-Autoscan directory for all xml filenames
-Build map of <type-name: tree> 'tree' to a list of strings (component names) -> [arguments](int/string/float component arguments)
-Type map is queried to create types of entity.
	-Entity factory exists that creates an entity from a list of component definitions -> see below
	-Component factory exists that creates a component from a component string and list of arguments

BEHAVIOUR
- Add a 'patrol' component; with variable parameters that a system will use to enact on them.

GAMEPLAY STUFF
- Player is a *single* 'drone', with movement of the drone detached from the global camera.
- Selection system for building stuff (Move up to a scaffold to enable construction => mechanic?)
- Implement fading of terrain on change OR craploads of intermediate terrain types (probably better).
i.e:
Low T, Low P; Desolate moon.
High T, Low P; Mercury or somewhat molten
High T, High P; Venus-like
Low T, High P; Gassy; either giant or methane lakes etc

-Perhaps scatter the archetypes of amino generators (randomly) across the map at the beginning; hidden in artefacts (archives)
-Amino generators will only function when planetoid has an appropriate habitat for the relevant units that are being created.




